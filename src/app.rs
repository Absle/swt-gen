use std::collections::VecDeque;

use eframe::{App, Frame};

use egui::{
    vec2, CentralPanel, Color32, ColorImage, ComboBox, Context, FontId, Grid, Image, Label, Pos2,
    Rect, RichText, ScrollArea, Sense, TextEdit, TextStyle, Ui, Vec2,
};
use egui_extras::RetainedImage;

use crate::astrography::{Point, Subsector};

use crate::astrography::table::{CulturalDiffRecord, GovRecord, TABLES};

use crate::astrography::world::{Faction, TravelCode, World};

/** Set of messages respresenting all non-trivial GUI events. */
enum Message {
    HexGridClicked {
        new_point: Point,
    },
    RedrawSubsectorImage,
    SaveWorld,
    // TODO
    #[allow(dead_code)]
    WorldLocUpdated,
    WorldDiameterUpdated,
    WorldModelUpdated,
    RegenWorldSize,
    RegenWorldAtmosphere,
    RegenWorldTemperature,
    RegenWorldHydrographics,
    RegenWorldPopulation,
    NewWorldGovSelected {
        new_code: u16,
    },
    RegenWorldGovernment,
    RegenWorldLawLevel,
    AddNewFaction,
    RemoveSelectedFaction,
    NewFactionGovSelected {
        new_code: u16,
    },
    RegenSelectedFaction,
    NewWorldCultureSelected {
        new_code: u16,
    },
    RegenWorldCulture,
}

#[derive(PartialEq)]
enum TabLabel {
    PlanetarySurvey,
    GovernmentLaw,
    Factions,
    CultureErrata,
    Notes,
}

impl ToString for TabLabel {
    fn to_string(&self) -> String {
        use TabLabel::*;
        match self {
            PlanetarySurvey => "Planetary Survey".to_string(),
            GovernmentLaw => "Government & Law".to_string(),
            Factions => "Factions".to_string(),
            CultureErrata => "Culture & Errata".to_string(),
            Notes => "Notes".to_string(),
        }
    }
}

pub struct GeneratorApp {
    subsector: Subsector,
    subsector_svg: String,
    subsector_image: RetainedImage,

    message_queue: VecDeque<Message>,

    /// A point is currently selected
    point_selected: bool,
    selected_point: Point,

    /// A world is currently selected
    world_selected: bool,
    selected_world: World,

    selected_tab: TabLabel,
    selected_faction_index: usize,

    // Mirror fields
    world_loc: String,
    world_diameter: String,
}

impl GeneratorApp {
    const SUBSECTOR_IMAGE_MIN_SIZE: Vec2 = vec2(1584.0, 834.0);

    const LABEL_FONT: FontId = FontId::proportional(11.0);
    const LABEL_COLOR: Color32 = Color32::GRAY;
    const LABEL_SPACING: f32 = 4.0;

    const BUTTON_FONT_SIZE: f32 = 16.0;

    const FIELD_SPACING: f32 = 15.0;
    const FIELD_SELECTION_WIDTH: f32 = 225.0;

    /** Queue a message to be handled at the beginning of the next frame. */
    fn message_next_frame(&mut self, message: Message) {
        self.message_queue.push_back(message);
    }

    /** Process all messages in the queue. */
    fn process_message_queue(&mut self) {
        while !self.message_queue.is_empty() {
            let message = self.message_queue.pop_front().unwrap();
            self.message_immediate(message);
        }
    }

    /** Handle a `Message` generated by a GUI event immediately. */
    fn message_immediate(&mut self, message: Message) {
        use Message::*;
        match message {
            HexGridClicked { new_point } => {
                self.message_next_frame(Message::RedrawSubsectorImage);

                if self.world_selected {
                    self.message_immediate(Message::SaveWorld);
                }

                self.point_selected = true;
                self.selected_point = new_point;
                self.selected_faction_index = 0;
                let world = self.subsector.map.get(&self.selected_point);
                if let Some(world) = world {
                    self.world_selected = true;
                    self.selected_world = world.clone();
                    self.world_loc = self.selected_world.location.to_string();
                    self.world_diameter = self.selected_world.diameter.to_string();
                } else {
                    self.world_selected = false;
                }
            }

            RedrawSubsectorImage => self.redraw_subsector_image(),

            SaveWorld => {
                self.subsector
                    .map
                    .insert(self.selected_point.clone(), self.selected_world.clone());
            }

            // TODO
            WorldLocUpdated => {
                todo!("Add ability to change world location.")
            }

            WorldDiameterUpdated => {
                if let Ok(diameter) = self.world_diameter.parse::<u32>() {
                    self.selected_world.diameter = diameter;
                } else {
                    self.world_diameter = self.selected_world.diameter.to_string();
                }
            }

            WorldModelUpdated => self.selected_world.resolve_trade_codes(),

            RegenWorldSize => {
                self.selected_world.generate_size();
                self.message_next_frame(Message::WorldModelUpdated);
            }

            RegenWorldAtmosphere => {
                self.selected_world.generate_atmosphere();
                self.message_next_frame(Message::WorldModelUpdated);
            }

            RegenWorldTemperature => {
                self.selected_world.generate_temperature();
                self.message_next_frame(Message::WorldModelUpdated);
            }

            RegenWorldHydrographics => {
                self.selected_world.generate_hydrographics();
                self.message_next_frame(Message::WorldModelUpdated);
            }

            RegenWorldPopulation => {
                self.selected_world.generate_population();
                self.message_next_frame(Message::WorldModelUpdated);
            }

            NewWorldGovSelected { new_code } => {
                let old_code = self.selected_world.government.code as usize;
                let old_description = &mut self.selected_world.government.description;

                // Replace existing description iff the user hasn't changed it from the default
                if *old_description == TABLES.gov_table[old_code].description {
                    *old_description = TABLES.gov_table[new_code as usize].description.clone();
                }

                self.selected_world.government.code = new_code;
                self.message_next_frame(Message::WorldModelUpdated);
            }

            RegenWorldGovernment => {
                let old_code = self.selected_world.government.code as usize;
                let old_description = self.selected_world.government.description.clone();
                let old_contraband = self.selected_world.government.contraband.clone();
                self.selected_world.generate_government();

                // If description or contraband have been changed from the default, keep them;
                // otherwise, allow them to be overwritten by the new government's default
                if old_description != TABLES.gov_table[old_code].description {
                    self.selected_world.government.description = old_description;
                }
                if old_contraband != TABLES.gov_table[old_code].contraband {
                    self.selected_world.government.contraband = old_contraband;
                }

                self.message_next_frame(Message::WorldModelUpdated);
            }

            RegenWorldLawLevel => {
                self.selected_world.generate_law_level();
                self.message_next_frame(Message::WorldModelUpdated);
            }

            AddNewFaction => {
                self.selected_world.factions.push(Faction::random());
                // Select the newly generated faction
                self.selected_faction_index = self.selected_world.factions.len() - 1;
            }

            RemoveSelectedFaction => {
                self.selected_world
                    .factions
                    .remove(self.selected_faction_index);
            }

            NewFactionGovSelected { new_code } => {
                let fac_index = self.selected_faction_index;
                let old_code = self.selected_world.factions[fac_index].government.code as usize;
                let old_description = &mut self.selected_world.factions[fac_index]
                    .government
                    .description;

                // Replace existing description iff the user hasn't changed it from the default
                if *old_description == TABLES.gov_table[old_code].description {
                    *old_description = TABLES.gov_table[new_code as usize].description.clone();
                }

                self.selected_world.factions[fac_index].government.code = new_code;
            }

            RegenSelectedFaction => {
                let index = self.selected_faction_index;
                if let Some(faction) = self.selected_world.factions.get_mut(index) {
                    let old_code = faction.government.code as usize;
                    let name = faction.name.clone();
                    let old_description = faction.government.description.clone();
                    *faction = Faction::random();

                    faction.name = name;
                    if old_description != TABLES.gov_table[old_code].description {
                        faction.government.description = old_description;
                    }
                }
            }

            NewWorldCultureSelected { new_code } => {
                let old_code = self.selected_world.culture.code as usize;
                let old_description = &mut self.selected_world.culture.description;

                // Replace existing description iff the user hasn't changed it from the default
                if *old_description == TABLES.culture_table[old_code].description {
                    *old_description = TABLES.culture_table[new_code as usize].description.clone();
                }

                self.selected_world.culture.code = new_code;
            }

            RegenWorldCulture => {
                let old_code = self.selected_world.culture.code as usize;
                let old_description = self.selected_world.culture.description.clone();
                self.selected_world.generate_culture();

                if old_description != TABLES.culture_table[old_code].description {
                    self.selected_world.culture.description = old_description;
                }
            }
        }
    }

    /** Regenerate `subsector_svg` and `subsector_image` after a change to `subsector`.

    "Redraw" is actually a misgnomer since it's redrawn every frame, but "regenerate" isn't as
    descriptive.
    */
    fn redraw_subsector_image(&mut self) {
        self.subsector_svg = self.subsector.generate_svg();
        self.subsector_image =
            generate_subsector_image(self.subsector.name(), &self.subsector_svg).unwrap();
    }

    fn central_panel(&mut self, ctx: &Context) {
        CentralPanel::default().show(ctx, |ui| {
            ui.horizontal_top(|ui| {
                self.subsector_map_display(ctx, ui);

                ui.separator();

                if self.point_selected && self.world_selected {
                    self.world_data_display(ui);
                }
            });
        });
    }

    fn subsector_map_display(&mut self, ctx: &Context, ui: &mut Ui) {
        let max_size = ui.available_size();
        ui.set_min_size(Self::SUBSECTOR_IMAGE_MIN_SIZE);
        ui.set_max_size(max_size);

        let mut desired_size = self.subsector_image.size_vec2();
        desired_size *= (max_size.x / desired_size.x).min(1.0);
        desired_size *= (max_size.y / desired_size.y).min(1.0);

        let subsector_image =
            Image::new(self.subsector_image.texture_id(&ctx), desired_size).sense(Sense::click());

        let response = ui.add(subsector_image);
        if response.clicked() {
            if let Some(pointer_pos) = response.interact_pointer_pos() {
                let new_point = pointer_pos_to_hex_point(pointer_pos, &response.rect);

                // A new point has been selected
                if let Some(new_point) = new_point {
                    self.message_immediate(Message::HexGridClicked { new_point });
                }
            }
        }
    }

    fn world_data_display(&mut self, ui: &mut Ui) {
        ui.vertical(|ui| {
            self.profile_display(ui);

            ui.add_space(Self::FIELD_SPACING);

            self.tab_labels(ui);
            ui.separator();

            use TabLabel::*;
            match self.selected_tab {
                PlanetarySurvey => self.survey_data_display(ui),
                GovernmentLaw => self.government_law_display(ui),
                Factions => self.factions_display(ui),
                CultureErrata => self.culture_errata_display(ui),
                Notes => (),
            }
        });
    }

    fn profile_display(&mut self, ui: &mut Ui) {
        ui.add(TextEdit::singleline(&mut self.selected_world.name).font(TextStyle::Heading));
        Grid::new("world_profile_grid")
            .spacing([Self::FIELD_SPACING / 2.0, Self::LABEL_SPACING])
            .min_col_width(100.0)
            .max_col_width(200.0)
            .show(ui, |ui| {
                ui.label(
                    RichText::new("Location")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.label(
                    RichText::new("World Profile")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.label(
                    RichText::new("Trade Codes")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.label(
                    RichText::new("Travel Code")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.end_row();

                // Location
                // TODO hook a message into this
                ui.add(TextEdit::singleline(&mut self.world_loc).desired_width(50.0));

                // World profile
                let profile = self.selected_world.profile();
                if ui.add(Label::new(&profile).sense(Sense::click())).clicked() {
                    ui.output().copied_text = profile;
                }

                // Trade codes
                let trade_codes = self.selected_world.trade_code_str();
                if ui
                    .add(Label::new(&trade_codes).sense(Sense::click()))
                    .clicked()
                {
                    ui.output().copied_text = trade_codes;
                }

                // Travel Code
                ComboBox::from_id_source("travel_code_selection")
                    .selected_text(self.selected_world.travel_code_str())
                    .show_ui(ui, |ui| {
                        for code in [TravelCode::Safe, TravelCode::Amber, TravelCode::Red] {
                            ui.selectable_value(
                                &mut self.selected_world.travel_code,
                                code,
                                format!("{:?}", code),
                            );
                        }
                    });

                // Gas giant presence
                ui.checkbox(
                    &mut self.selected_world.has_gas_giant,
                    RichText::new("Gas Giant Present")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
            });
    }

    fn tab_labels(&mut self, ui: &mut Ui) {
        use TabLabel::*;
        ui.horizontal(|ui| {
            for tab_label in [
                PlanetarySurvey,
                GovernmentLaw,
                Factions,
                CultureErrata,
                Notes,
            ] {
                let text = tab_label.to_string();
                ui.selectable_value(&mut self.selected_tab, tab_label, text);
            }
        });
    }

    fn survey_data_display(&mut self, ui: &mut Ui) {
        ui.heading("Planetary Data");
        ui.add_space(Self::LABEL_SPACING);

        self.size_display(ui);
        ui.add_space(Self::FIELD_SPACING);

        self.atmosphere_display(ui);
        ui.add_space(Self::FIELD_SPACING);

        self.temperature_display(ui);
        ui.add_space(Self::FIELD_SPACING);

        self.hydrographics_display(ui);
        ui.add_space(Self::FIELD_SPACING);

        self.population_display(ui);
        ui.add_space(Self::FIELD_SPACING);
    }

    fn government_law_display(&mut self, ui: &mut Ui) {
        ui.columns(2, |columns| {
            self.government_display(&mut columns[0]);
            self.law_level_display(&mut columns[1]);
        });
    }

    fn culture_errata_display(&mut self, ui: &mut Ui) {
        ui.columns(2, |columns| {
            self.culture_display(&mut columns[0]);
            columns[1].heading("World Tags");
        });
    }

    fn size_display(&mut self, ui: &mut Ui) {
        Grid::new("world_size_grid")
            .spacing([Self::FIELD_SPACING, Self::LABEL_SPACING])
            .show(ui, |ui| {
                ui.label(
                    RichText::new("Size")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.label(
                    RichText::new("Diameter (km)")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.end_row();

                // Size code
                ComboBox::from_id_source("size_selection")
                    .selected_text(format!("{}", self.selected_world.size))
                    .width(45.0)
                    .show_ui(ui, |ui| {
                        for size in World::SIZE_MIN..=World::SIZE_MAX {
                            if ui
                                .selectable_value(
                                    &mut self.selected_world.size,
                                    size,
                                    format!("{:?}", size),
                                )
                                .clicked()
                            {
                                self.message_next_frame(Message::WorldModelUpdated);
                            }
                        }
                    });

                // Diameter
                if ui
                    .add(TextEdit::singleline(&mut self.world_diameter).desired_width(50.0))
                    .lost_focus()
                {
                    self.message_immediate(Message::WorldDiameterUpdated);
                }

                if ui
                    .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                    .clicked()
                {
                    self.message_immediate(Message::RegenWorldSize);
                }
            });
    }

    fn atmosphere_display(&mut self, ui: &mut Ui) {
        ui.label(
            RichText::new("Atmosphere")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal(|ui| {
            ComboBox::from_id_source("atmosphere_selection")
                .selected_text(format!(
                    "{}: {}",
                    self.selected_world.atmosphere.code,
                    TABLES.atmo_table[self.selected_world.atmosphere.code as usize].composition
                ))
                .width(Self::FIELD_SELECTION_WIDTH)
                .show_ui(ui, |ui| {
                    for atmo in TABLES.atmo_table.iter() {
                        if ui
                            .selectable_value(
                                &mut self.selected_world.atmosphere,
                                atmo.clone(),
                                format!(
                                    "{}: {}",
                                    atmo.code, TABLES.atmo_table[atmo.code as usize].composition
                                ),
                            )
                            .clicked()
                        {
                            self.message_next_frame(Message::WorldModelUpdated);
                        }
                    }
                });
            ui.add_space(Self::FIELD_SPACING);

            if ui
                .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                .clicked()
            {
                self.message_immediate(Message::RegenWorldAtmosphere);
            }
        });
    }

    fn temperature_display(&mut self, ui: &mut Ui) {
        ui.label(
            RichText::new("Temperature")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal(|ui| {
            ComboBox::from_id_source("temperature_selection")
                .selected_text(format!(
                    "{}: {}",
                    self.selected_world.temperature.code,
                    TABLES.temp_table[self.selected_world.temperature.code as usize].kind
                ))
                .width(Self::FIELD_SELECTION_WIDTH)
                .show_ui(ui, |ui| {
                    for temp in TABLES.temp_table.iter() {
                        if ui
                            .selectable_value(
                                &mut self.selected_world.temperature,
                                temp.clone(),
                                format!(
                                    "{}: {}",
                                    temp.code, TABLES.temp_table[temp.code as usize].kind
                                ),
                            )
                            .clicked()
                        {
                            self.message_next_frame(Message::WorldModelUpdated);
                        }
                    }
                });
            ui.add_space(Self::FIELD_SPACING);

            if ui
                .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                .clicked()
            {
                self.message_immediate(Message::RegenWorldTemperature);
            }
        });
    }

    fn hydrographics_display(&mut self, ui: &mut Ui) {
        ui.label(
            RichText::new("Hydrographics")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal(|ui| {
            ComboBox::from_id_source("hydrographics_selection")
                .selected_text(format!(
                    "{}: {}",
                    self.selected_world.hydrographics.code,
                    TABLES.hydro_table[self.selected_world.hydrographics.code as usize].description
                ))
                .width(Self::FIELD_SELECTION_WIDTH)
                .show_ui(ui, |ui| {
                    for hydro in TABLES.hydro_table.iter() {
                        if ui
                            .selectable_value(
                                &mut self.selected_world.hydrographics,
                                hydro.clone(),
                                format!(
                                    "{}: {}",
                                    hydro.code, TABLES.hydro_table[hydro.code as usize].description
                                ),
                            )
                            .clicked()
                        {
                            self.message_next_frame(Message::WorldModelUpdated);
                        }
                    }
                });
            ui.add_space(Self::FIELD_SPACING);

            if ui
                .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                .clicked()
            {
                self.message_immediate(Message::RegenWorldHydrographics);
            }
        });
    }

    fn population_display(&mut self, ui: &mut Ui) {
        ui.label(
            RichText::new("Population")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal(|ui| {
            ComboBox::from_id_source("population_selection")
                .selected_text(format!(
                    "{}: {}",
                    self.selected_world.population.code,
                    TABLES.pop_table[self.selected_world.population.code as usize].inhabitants
                ))
                .width(Self::FIELD_SELECTION_WIDTH)
                .show_ui(ui, |ui| {
                    for pop in TABLES.pop_table.iter() {
                        if ui
                            .selectable_value(
                                &mut self.selected_world.population,
                                pop.clone(),
                                format!(
                                    "{}: {}",
                                    pop.code, TABLES.pop_table[pop.code as usize].inhabitants
                                ),
                            )
                            .clicked()
                        {
                            self.message_next_frame(Message::WorldModelUpdated);
                        }
                    }
                });
            ui.add_space(Self::FIELD_SPACING);

            if ui
                .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                .clicked()
            {
                self.message_immediate(Message::RegenWorldPopulation);
            }
        });
    }

    fn government_display(&mut self, ui: &mut Ui) {
        ui.heading("Government");
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal(|ui| {
            ComboBox::from_id_source("government_selection")
                .selected_text(format!(
                    "{}: {}",
                    self.selected_world.government.code,
                    TABLES.gov_table[self.selected_world.government.code as usize].kind
                ))
                .width(Self::FIELD_SELECTION_WIDTH)
                .show_ui(ui, |ui| {
                    for gov in TABLES.gov_table.iter() {
                        let GovRecord {
                            kind: world_gov_kind,
                            ..
                        } = &mut self.selected_world.government;

                        if ui
                            .selectable_value(
                                world_gov_kind,
                                gov.kind.clone(),
                                format!("{}: {}", gov.code, gov.kind),
                            )
                            .on_hover_text(&gov.description)
                            .clicked()
                        {
                            self.message_immediate(Message::NewWorldGovSelected {
                                new_code: gov.code,
                            });
                        }
                    }
                });
            ui.add_space(Self::FIELD_SPACING);

            if ui
                .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                .clicked()
            {
                self.message_immediate(Message::RegenWorldGovernment);
            }
        });

        ui.add_space(Self::LABEL_SPACING * 1.5);
        ui.label(
            RichText::new("Contraband")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ui.add(
            TextEdit::singleline(&mut self.selected_world.government.contraband)
                .desired_width(Self::FIELD_SELECTION_WIDTH),
        )
        .on_hover_text(format!(
            "Common contraband: {}",
            TABLES.gov_table[self.selected_world.government.code as usize].contraband
        ));

        ui.add_space(Self::LABEL_SPACING * 1.5);
        ui.label(
            RichText::new("Description")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ScrollArea::vertical().show(ui, |ui| {
            ui.add(TextEdit::multiline(
                &mut self.selected_world.government.description,
            ));
        });
    }

    fn law_level_display(&mut self, ui: &mut Ui) {
        ui.heading("Law Level");
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal(|ui| {
            ComboBox::from_id_source("law_level_selection")
                .selected_text(format!("{}", self.selected_world.law_level.code))
                .width(45.0)
                .show_ui(ui, |ui| {
                    for law_level in TABLES.law_table.iter() {
                        if ui
                            .selectable_value(
                                &mut self.selected_world.law_level,
                                law_level.clone(),
                                law_level.code.to_string(),
                            )
                            .clicked()
                        {
                            self.message_next_frame(Message::WorldModelUpdated);
                        }
                    }
                });
            ui.add_space(Self::FIELD_SPACING);

            if ui
                .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                .clicked()
            {
                self.message_immediate(Message::RegenWorldLawLevel);
            }
        });

        Grid::new("banned_equipment_grid")
            .spacing([Self::FIELD_SPACING / 2.0, Self::LABEL_SPACING])
            .min_col_width(Self::FIELD_SELECTION_WIDTH)
            .max_col_width(Self::FIELD_SELECTION_WIDTH)
            .striped(true)
            .show(ui, |ui| {
                ui.label(
                    RichText::new("Banned Weapons")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.label(
                    RichText::new("Banned Armor")
                        .font(Self::LABEL_FONT)
                        .color(Self::LABEL_COLOR),
                );
                ui.end_row();

                let law_level = self.selected_world.law_level.code as usize;
                for i in 0..=law_level {
                    ui.label(&TABLES.law_table[i].banned_weapons);
                    ui.label(&TABLES.law_table[i].banned_armor);
                    ui.end_row();
                }
            });
    }

    fn factions_display(&mut self, ui: &mut Ui) {
        ui.label(
            RichText::new("Factions")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal_top(|ui| {
            ui.vertical(|ui| {
                ui.set_width(150.0);
                ScrollArea::vertical()
                    .id_source("faction_selection")
                    .show(ui, |ui| {
                        for (index, faction) in self.selected_world.factions.iter().enumerate() {
                            ui.selectable_value(
                                &mut self.selected_faction_index,
                                index,
                                &faction.name,
                            );
                        }
                        if ui.button("+").clicked() {
                            self.message_immediate(Message::AddNewFaction)
                        }
                    });
            });

            let fac_idx = self.selected_faction_index;
            if self.selected_world.factions.get(fac_idx).is_some() {
                ui.vertical(|ui| {
                    ui.set_width(Self::FIELD_SELECTION_WIDTH * 2.5);
                    ui.horizontal(|ui| {
                        if ui
                            .button(
                                RichText::new("ðŸŽ²")
                                    .font(FontId::proportional(Self::BUTTON_FONT_SIZE)),
                            )
                            .clicked()
                        {
                            self.message_immediate(Message::RegenSelectedFaction);
                        }

                        if ui
                            .button(
                                RichText::new("âŒ")
                                    .font(FontId::proportional(Self::BUTTON_FONT_SIZE)),
                            )
                            .on_hover_text_at_pointer("Double click to delete this faction")
                            .double_clicked()
                        {
                            self.message_immediate(Message::RemoveSelectedFaction);
                        }
                    });

                    ui.add(
                        TextEdit::singleline(&mut self.selected_world.factions[fac_idx].name)
                            .desired_width(Self::FIELD_SELECTION_WIDTH),
                    );
                    ui.add_space(Self::LABEL_SPACING * 1.5);

                    ui.label(
                        RichText::new("Strength")
                            .font(Self::LABEL_FONT)
                            .color(Self::LABEL_COLOR),
                    );
                    ui.add_space(Self::LABEL_SPACING);

                    let strength_code = self.selected_world.factions[fac_idx].code as usize;
                    ComboBox::from_id_source("faction_strength_selection")
                        .selected_text(format!(
                            "{}: {}",
                            strength_code, TABLES.faction_table[strength_code].strength
                        ))
                        .width(Self::FIELD_SELECTION_WIDTH)
                        .show_ui(ui, |ui| {
                            for faction in TABLES.faction_table.iter() {
                                let Faction { code, strength, .. } =
                                    &mut self.selected_world.factions[fac_idx];

                                if ui
                                    .selectable_value(
                                        strength,
                                        faction.strength.clone(),
                                        format!("{}: {}", faction.code, faction.strength),
                                    )
                                    .clicked()
                                {
                                    *code = faction.code;
                                }
                            }
                        });
                    ui.add_space(Self::LABEL_SPACING * 1.5);

                    ui.label(
                        RichText::new("Leadership")
                            .font(Self::LABEL_FONT)
                            .color(Self::LABEL_COLOR),
                    );
                    ui.add_space(Self::LABEL_SPACING);

                    let gov_code = self.selected_world.factions[fac_idx].government.code as usize;
                    ComboBox::from_id_source("faction_government_selection")
                        .selected_text(format!("{}: {}", gov_code, TABLES.gov_table[gov_code].kind))
                        .width(Self::FIELD_SELECTION_WIDTH)
                        .show_ui(ui, |ui| {
                            for gov in TABLES.gov_table.iter() {
                                let GovRecord {
                                    kind: fac_gov_kind, ..
                                } = &mut self.selected_world.factions[fac_idx].government;

                                if ui
                                    .selectable_value(
                                        fac_gov_kind,
                                        gov.kind.clone(),
                                        format!("{}: {}", gov.code, gov.kind),
                                    )
                                    .on_hover_text(&gov.description)
                                    .clicked()
                                {
                                    self.message_immediate(Message::NewFactionGovSelected {
                                        new_code: gov.code,
                                    });
                                }
                            }
                        });
                    ui.add_space(Self::LABEL_SPACING * 1.5);

                    ui.label(
                        RichText::new("Description")
                            .font(Self::LABEL_FONT)
                            .color(Self::LABEL_COLOR),
                    );
                    ui.add_space(Self::LABEL_SPACING);

                    ScrollArea::vertical()
                        .id_source("faction_description")
                        .show(ui, |ui| {
                            let GovRecord { description, .. } =
                                &mut self.selected_world.factions[fac_idx].government;
                            ui.add(TextEdit::multiline(description).desired_width(f32::INFINITY))
                        });
                });
            }
        });
    }

    fn culture_display(&mut self, ui: &mut Ui) {
        ui.heading("Culture");
        ui.add_space(Self::LABEL_SPACING);

        ui.horizontal(|ui| {
            let code = self.selected_world.culture.code as usize;
            ComboBox::from_id_source("culture_selection")
                .selected_text(&TABLES.culture_table[code].cultural_difference)
                .width(Self::FIELD_SELECTION_WIDTH)
                .show_ui(ui, |ui| {
                    for item in TABLES.culture_table.iter() {
                        let CulturalDiffRecord {
                            cultural_difference,
                            ..
                        } = &mut self.selected_world.culture;

                        if ui
                            .selectable_value(
                                cultural_difference,
                                item.cultural_difference.clone(),
                                &item.cultural_difference,
                            )
                            .on_hover_text(&item.description)
                            .clicked()
                        {
                            self.message_immediate(Message::NewWorldCultureSelected {
                                new_code: item.code,
                            });
                        }
                    }
                });
            ui.add_space(Self::FIELD_SPACING);

            if ui
                .button(RichText::new("ðŸŽ²").font(FontId::proportional(Self::BUTTON_FONT_SIZE)))
                .clicked()
            {
                // TODO
                self.message_immediate(Message::RegenWorldCulture);
            }
        });
        ui.add_space(Self::LABEL_SPACING * 1.5);

        ui.label(
            RichText::new("Description")
                .font(Self::LABEL_FONT)
                .color(Self::LABEL_COLOR),
        );
        ui.add_space(Self::LABEL_SPACING);

        ScrollArea::vertical().show(ui, |ui| {
            ui.add(TextEdit::multiline(
                &mut self.selected_world.culture.description,
            ));
        });
    }
}

impl Default for GeneratorApp {
    fn default() -> Self {
        let subsector = Subsector::default();
        let subsector_svg = subsector.generate_svg();
        let subsector_image = generate_subsector_image(subsector.name(), &subsector_svg).unwrap();
        let message_queue = VecDeque::new();
        let selected_point = Point::default();
        let selected_world = World::empty();
        let world_loc = String::new();
        let world_diameter = String::new();

        Self {
            subsector,
            subsector_svg,
            subsector_image,
            message_queue,
            point_selected: false,
            world_selected: false,
            selected_point,
            selected_world,
            selected_tab: TabLabel::PlanetarySurvey,
            selected_faction_index: 0,
            world_loc,
            world_diameter,
        }
    }
}

impl App for GeneratorApp {
    fn update(&mut self, ctx: &Context, _frame: &mut Frame) {
        self.process_message_queue();
        self.central_panel(ctx);
    }
}

/** Generate `RetainedImage` from a `Subsector`. */
fn generate_subsector_image(name: &str, svg: &String) -> Result<RetainedImage, String> {
    Ok(RetainedImage::from_color_image(
        format!("{}.svg", name),
        load_svg_bytes(svg.as_bytes())?,
    ))
}

/** Load an SVG and rasterize it into a `ColorImage`.

## Errors
On invalid SVG.
*/
fn load_svg_bytes(svg_bytes: &[u8]) -> Result<ColorImage, String> {
    let mut opt = usvg::Options {
        font_family: system_sans_serif_font(),
        ..Default::default()
    };
    opt.fontdb.load_system_fonts();

    let rtree = usvg::Tree::from_data(svg_bytes, &opt.to_ref()).map_err(|err| err.to_string())?;

    let pixmap_size = rtree.svg_node().size.to_screen_size();
    let [w, h] = [pixmap_size.width(), pixmap_size.height()];

    let mut pixmap = tiny_skia::Pixmap::new(w, h)
        .ok_or_else(|| format!("Failed to create SVG Pixmap of size {}x{}", w, h))?;

    resvg::render(
        &rtree,
        usvg::FitTo::Original,
        tiny_skia::Transform::default(),
        pixmap.as_mut(),
    )
    .ok_or_else(|| "Failed to render SVG".to_owned())?;

    let image = ColorImage::from_rgba_unmultiplied(
        [pixmap.width() as _, pixmap.height() as _],
        pixmap.data(),
    );

    Ok(image)
}

/** Return name of system default sans-serif font. */
fn system_sans_serif_font() -> String {
    #[cfg(target_os = "windows")]
    {
        "Arial".to_string()
    }

    #[cfg(target_os = "macos")]
    {
        "San Francisco".to_string()
    }

    // Linux
    #[cfg(all(unix, not(any(target_os = "macos", target_os = "android"))))]
    {
        "Liberation Sans".to_string()
    }
}

/** Return `Point` of clicked hex or `None` if click position is outside the hex grid. */
fn pointer_pos_to_hex_point(pointer_pos: Pos2, rect: &Rect) -> Option<Point> {
    // In inches
    const SVG_WIDTH: f32 = 8.5;
    const SVG_HEIGHT: f32 = 11.0;

    // Margins around hex grid in inches
    const LEFT_MARGIN: f32 = 1.0;
    const RIGHT_MARGIN: f32 = LEFT_MARGIN;
    const TOP_MARGIN: f32 = 0.5;
    const BOTTOM_MARGIN: f32 = 1.0;

    // Hex dimensions in inches
    const HEX_LONG_RADIUS: f32 = 0.52;
    const HEX_LONG_DIAMETER: f32 = HEX_LONG_RADIUS * 2.0;
    const HEX_SHORT_RADIUS: f32 = 0.45;
    const HEX_SHORT_DIAMETER: f32 = HEX_SHORT_RADIUS * 2.0;

    let pixels_per_inch = rect.width() / SVG_WIDTH;

    let left_bound = LEFT_MARGIN * pixels_per_inch;
    let right_bound = (SVG_WIDTH - RIGHT_MARGIN) * pixels_per_inch;
    let top_bound = TOP_MARGIN * pixels_per_inch;
    let bottom_bound = (SVG_HEIGHT - BOTTOM_MARGIN) * pixels_per_inch;

    let left_top = Pos2::from([left_bound, top_bound]);
    let right_bottom = Pos2::from([right_bound, bottom_bound]);
    let grid_rect = Rect::from_min_max(left_top, right_bottom);

    // Make sure click is inside the grid's rectangle, return None if not
    let relative_pos = pointer_pos - rect.left_top();
    let relative_pos = Pos2::from([relative_pos.x, relative_pos.y]);
    if !grid_rect.contains(relative_pos) {
        return None;
    }

    // Find the hex center that is nearest to the click position
    let mut smallest_distance = f32::MAX;
    let mut point = Point { x: 0, y: 0 };
    for x in 1..=Subsector::COLUMNS {
        for y in 1..=Subsector::ROWS {
            let center_x = ((x - 1) as f32 * 0.75 * HEX_LONG_DIAMETER + HEX_LONG_RADIUS)
                * pixels_per_inch
                + left_bound;

            // Even columns are shifted a short radius downwards
            let offset = if x % 2 == 0 {
                HEX_SHORT_RADIUS * pixels_per_inch
            } else {
                0.0
            };
            let center_y = ((y - 1) as f32 * HEX_SHORT_DIAMETER + HEX_SHORT_RADIUS)
                * pixels_per_inch
                + offset
                + top_bound;

            let center = Pos2::from([center_x, center_y]);
            let distance = center.distance(relative_pos);
            if distance < smallest_distance {
                smallest_distance = distance;
                point = Point {
                    x: x as u16,
                    y: y as u16,
                };
            }
        }
    }

    if smallest_distance < HEX_SHORT_RADIUS * pixels_per_inch {
        Some(point)
    } else {
        None
    }
}
